package se.hms.ewon.demostomp;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

@Component
public class ConnectionLimiterInterceptor implements  ChannelInterceptor {

	private Logger logger = LoggerFactory.getLogger(ConnectionLimiterInterceptor.class);
	private Set<String> connectedSessions = Collections.synchronizedSet(new HashSet<>());

	@Override
	public Message<?> preSend(final Message<?> message, final MessageChannel channel) {

		StompHeaderAccessor stompAccessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);

		if (stompAccessor == null) {
			stompAccessor = StompHeaderAccessor.wrap(message);
		}

		StompCommand command = stompAccessor.getCommand();
		if (logger.isTraceEnabled()){
			logger.trace("Got presend command: {}", command);
		}
		String sessionId = stompAccessor.getSessionId();

		if (sessionId != null) {
			if (StompCommand.CONNECT.equals(command) || StompCommand.STOMP.equals(command)) {
				if (sessionId != null && !connectedSessions.add(sessionId)){
					logger.info("Refusing CONNECT for {}", sessionId);
					return null; // Don't pass message along the stream.
				}
			} else if (StompCommand.DISCONNECT.equals(command) ) {
				removeSession(sessionId);
			}
		}
		return message;
	}

	private void removeSession(final String sessionId) {
		connectedSessions.remove(sessionId);
	}
}
